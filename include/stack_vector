#ifndef STD_EXPERIMENTAL_STACK_VECTOR
#define STD_EXPERIMENTAL_STACK_VECTOR
/// \file
///
/// Dynamically-resizable vector with stack storage.
#include <cassert>
#include <cstddef>    // for size_t
#include <iterator>   // for reverse_iterator
#include <stdexcept>  // for length_error
#include <type_traits>

namespace std {
namespace experimental {

#ifndef stack_vector_DOXYGEN_INVOKED

namespace stack_vector_detail {

/// Storage for a vector of non-trivial elements
template <typename T, size_t Capacity, bool IsTrivial /* = false */>
struct storage {
  static_assert(Capacity != size_t{0}, "");

 private:
  aligned_storage_t<sizeof(T), alignment_of<T>::value> data_[Capacity];
  size_t size_ = 0;

 public:
  /// Direct access to the underlying storage
  ///
  /// Time complexity: O(1)
  /// Space complexity: O(1)
  constexpr const T* data() const noexcept {
    return reinterpret_cast<T const*>(data_);
  }

  /// Direct access to the underlying storage
  ///
  /// Time complexity: O(1)
  /// Space complexity: O(1)
  constexpr T* data() noexcept { return reinterpret_cast<T*>(data_); }

  /// Number of elements in the vector
  ///
  /// Time complexity: O(1)
  /// Space complexity: O(1)
  constexpr size_t size() const noexcept { return size_; }

  /// TODO: constrain to Constructible<T, Args...>
  /// TODO: conditionally noexcept
  template <typename... Args>  //
  void emplace_back(Args&&... args) {
    assert(size() <= Capacity);
    new (data() + size()) T(forward<Args>(args)...);
    unsafe_set_size(size() + 1);
  }

  // calling pop back on an empty container is undefined
  // cannot be constexpr due to explicit destructor call
  void pop_back() noexcept(is_nothrow_destructible<T>{}) {
    assert(size() > 0);
    auto ptr = data() + size() - 1;
    ptr->~T();
    unsafe_set_size(size() - 1);
  }

 protected:
  /// Changes the container size (unsafe)
  constexpr void unsafe_set_size(size_t new_size) noexcept { size_ = new_size; }

  template <typename InputIterator>
  constexpr void unsafe_destroy(InputIterator first,
                                InputIterator last) noexcept {
    for (; first != last; ++first) { first->~T(); }
  }

  /// Destroys all elements of the vector without changing its size (unsafe)
  constexpr void unsafe_destroy_all() noexcept {
    unsafe_destroy(data(), data() + size());
  }

  /// Requires Copyable
  //
  // the only thing that can throw is the copy constructor, if it throws we bail
  template <class InputIterator>
  constexpr void copy_assign(InputIterator first, InputIterator last) {
    unsafe_destroy_all();
    unsafe_set_size(0);
    auto b = data();
    for (; first != last; ++first, ++b) {
      if (size() < Capacity) {
        new (b) T(*first);  // CopyConstructible
        ++size_;
      } else {
        unsafe_destroy_all();
        unsafe_set_size(0);
        throw length_error("");
      }
    }
  }

  /// Requires Movable (note: std::move_iterator is not constexpr)
  template <class InputIterator>
  constexpr void move_assign(InputIterator first, InputIterator last) {
    unsafe_destroy_all();
    unsafe_set_size(0);
    auto b = data();
    for (; first != last; ++first, ++b) {
      if (size() < Capacity) {
        new (b) T(std::move(*first));  // MoveConstructible
        ++size_;
      } else {
        unsafe_destroy_all();
        unsafe_set_size(0);
        throw length_error("");
      }
    }
  }

  constexpr void copy_assign(size_t n, T const& u) {
    unsafe_destroy_all();
    unsafe_set_size(0);
    auto b = data();
    for (; n != 0; --n, ++b) {
      if (size() < Capacity) {
        new (b) T(u);  // CopyConstructible
        ++size_;
      } else {
        unsafe_destroy_all();
        unsafe_set_size(0);
        throw length_error("");
      }
    }
  }

 public:
  constexpr storage()               = default;
  constexpr storage(storage const&) = default;
  constexpr storage& operator=(storage const&) = default;
  constexpr storage(storage&&)                 = default;
  constexpr storage& operator=(storage&&) = default;
  ~storage() { unsafe_destroy_all(); }
};

/// Storage for a vector of trivial elements
template <typename T, size_t Capacity>  //
struct storage<T, Capacity, true> {
  static_assert(Capacity != size_t{0}, "");

 private:
  T data_[Capacity];
  size_t size_ = 0;

 public:
  /// Direct access to the underlying storage
  ///
  /// Time complexity: O(1)
  /// Space complexity: O(1)
  constexpr const T* data() const noexcept {
    return reinterpret_cast<T const*>(data_);
  }

  /// Direct access to the underlying storage
  ///
  /// Time complexity: O(1)
  /// Space complexity: O(1)
  constexpr T* data() noexcept { return reinterpret_cast<T*>(data_); }

  /// Number of elements in the vector
  ///
  /// Time complexity: O(1)
  /// Space complexity: O(1)
  constexpr size_t size() const noexcept { return size_; }

  /// TODO: constrain to Constructible<T, Args...> and (MoveAssignable<T> or
  /// CopyAssignable<T>)
  /// TODO: conditionally noexcept
  template <typename... Args>  //
  constexpr void emplace_back(Args&&... args) {
    assert(size() <= Capacity);
    data_[size()] = T(forward<Args>(args)...);
    unsafe_set_size(size() + 1);
  }

  // calling pop back on an empty container is undefined
  constexpr void pop_back() noexcept {
    assert(size() > 0);
    unsafe_set_size(size() - 1);
  }

 protected:
  /// Changes the container size (unsafe)
  constexpr void unsafe_set_size(size_t new_size) noexcept { size_ = new_size; }

  /// Destroys all elements of the vector without changing its size (unsafe)
  static constexpr void unsafe_destroy_all() noexcept {}

  template <class InputIterator>
  void copy_assign(InputIterator first, InputIterator last) {
    size_t new_size = 0;
    auto b          = data();
    for (; first != last; ++first, ++b) {
      if (new_size < Capacity) {
        *b = *first;
        ++b;
        ++new_size;
      } else {
        throw length_error("");
      }
    }
    unsafe_set_size(new_size);
  }

  template <class InputIterator>
  void move_assign(InputIterator first, InputIterator last) {
    size_t new_size = 0;
    auto b          = data();
    for (; first != last; ++first, ++b) {
      if (new_size < Capacity) {
        *b = std::move(*first);
        ++b;
        ++new_size;
      } else {
        throw length_error("");
      }
    }
    unsafe_set_size(new_size);
  }

  void copy_assign(size_t n, const T& u) {
    if (n > Capacity) { throw length_error(""); }
    for (size_t i = 0; i != n; ++i) { data_[i] = u; }
    unsafe_set_size(n);
  }

 public:
  constexpr storage()               = default;
  constexpr storage(storage const&) = default;
  constexpr storage& operator=(storage const&) = default;
  constexpr storage(storage&&)                 = default;
  constexpr storage& operator=(storage&&) = default;
  // constexpr ~storage()                    = default;
};

template <typename T> struct empty_storage {
  /// Direct access to the underlying storage
  ///
  /// Time complexity: O(1)
  /// Space complexity: O(1)
  constexpr const T* data() const noexcept { return nullptr; }

  /// Direct access to the underlying storage
  ///
  /// Time complexity: O(1)
  /// Space complexity: O(1)
  constexpr T* data() noexcept { return nullptr; }

  /// Number of elements in the vector
  ///
  /// Time complexity: O(1)
  /// Space complexity: O(1)
  static constexpr size_t size() noexcept { return 0; }

  /// Changes the container size (unsafe)
  static constexpr void set_size(size_t new_size) noexcept {
    assert(new_size == size_t{0}
           && "trying to set the size of a zero-capacity vector to value != 0");
  }

  /// For trivially destructible types there is nothing to do
  static constexpr void unsafe_destroy_all() noexcept {}
};

template <typename T>  //
struct storage<T, 0, true> : empty_storage<T> {};

template <typename T>  //
struct storage<T, 0, false> : empty_storage<T> {};

}  // namespace stack_vector_detail

#endif  // stack_vector_DOXYGEN_INVOKED

/// Dynamically-resizable vector with stack storage
template <typename T, size_t Capacity>  //
struct stack_vector
 : private stack_vector_detail::storage<T, Capacity, is_trivial<T>{}> {
 private:
  using self   = stack_vector<T, Capacity>;
  using base_t = stack_vector_detail::storage<T, Capacity, is_trivial<T>{}>;

 public:
  using base_t::data;
  using base_t::size;
  using base_t::emplace_back;
  using base_t::pop_back;

 private:
  using base_t::unsafe_set_size;
  using base_t::unsafe_destroy_all;
  using base_t::copy_assign;
  using base_t::move_assign;

  static_assert(is_nothrow_destructible<T>{},
                "stack::vector requires T to be nothrow destructible");

 public:
  using value_type             = T;
  using reference              = value_type&;
  using const_reference        = value_type const&;
  using iterator               = T*;
  using const_iterator         = T const*;
  using size_type              = size_t;
  using difference_type        = ptrdiff_t;
  using pointer                = T*;
  using const_pointer          = T const*;
  using reverse_iterator       = typename std::reverse_iterator<iterator>;
  using const_reverse_iterator = typename std::reverse_iterator<const_iterator>;

  /// \name Construct/copy/move/destroy
  ///@{

  constexpr stack_vector() noexcept : base_t() {}

  /// Can always throw if n > capacity
  constexpr explicit stack_vector(size_type n) { copy_assign(n, T()); };

  /// can always throw if n > Capacity
  constexpr stack_vector(size_type n, const T& value) { copy_assign(n, value); }

  /// TODO: assert distance for RandomAccessIterator (QoI)
  /// can always throw if distance(first, last) > capacity
  template <class InputIterator>
  constexpr stack_vector(InputIterator first, InputIterator last) {
    copy_assign(std::move(first), std::move(last));
  }

  /// can always throw if other.size() > capacity() which can only happen if M >
  /// Capacity
  template <std::size_t M, enable_if_t<(Capacity != M)>>
  constexpr stack_vector(stack_vector<T, M> const& other) noexcept(
   M <= Capacity and is_nothrow_copy_constructible<T>{}
   and is_nothrow_copy_assignable<T>{}) {
    copy_assign(begin(other), end(other));
  }

  /// can always throw if other.size() > capacity() which can only happen if M >
  /// Capacity
  template <std::size_t M, enable_if_t<(Capacity != M)>>
  constexpr stack_vector(stack_vector<T, M>&& other) noexcept(
   M <= Capacity and is_nothrow_move_constructible<T>{}
   and is_nothrow_move_assignable<T>{}) {
    move_assign(begin(other), end(other));
  }

  /// same capacity so can only throw if copy constructor or copy assignment can
  /// throw
  constexpr stack_vector(stack_vector const& other) noexcept(
   is_nothrow_copy_assignable<T>{} and is_nothrow_copy_constructible<T>{}) {
    copy_assign(begin(other), end(other));
  }

  /// same capacity so can only throw if move constructor or move assignment can
  /// throw
  constexpr stack_vector(stack_vector&& other) noexcept(
   is_nothrow_move_assignable<T>{} and is_nothrow_move_constructible<T>{}) {
    move_assign(begin(other), end(other));
  }
  // can always throw if il.size() > capacity()
  constexpr stack_vector(initializer_list<T> il) {
    copy_assign(begin(il), end(il));
  }

  // using base_t::~base_t;  // inheriting the destructor allows this type to be
  //                         // trivially destructible

  /// same capacity so can only thow if copy constructor or copy assignment
  /// throws
  ///
  /// cannot provide strong exception guarantee
  constexpr stack_vector& operator=(stack_vector const& other) noexcept(
   is_nothrow_copy_constructible<T>{} and is_nothrow_copy_assignable<T>{}) {
    copy_assign(begin(other), end(other));
  }
  /// same capacity so can only thow if copy constructor or copy assignment
  /// throws
  ///
  /// cannot provide strong exception guarantee
  constexpr stack_vector& operator=(stack_vector&& other) noexcept(
   is_nothrow_move_assignable<T>{} and is_nothrow_move_constructible<T>{}) {
    move_assign(begin(other), end(other));
  }

  /// TODO: conditionally noexcept
  template <std::size_t M, enable_if_t<(Capacity != M)>>
  constexpr stack_vector& operator=(stack_vector<T, M> const& other) noexcept(
   is_nothrow_copy_constructible<T>{} and is_nothrow_copy_assignable<T>{}) {
    copy_assign(begin(other), end(other));
  }
  /// TODO: conditionally noexcept
  template <std::size_t M, enable_if_t<(Capacity != M)>>
  constexpr stack_vector& operator=(stack_vector<T, M>&& other) noexcept(
   is_nothrow_move_assignable<T>{} and is_nothrow_move_constructible<T>{}) {
    move_assign(begin(other), end(other));
  }

  template <class InputIterator>
  constexpr void assign(InputIterator first, InputIterator last) {
    copy_assign(first, last);
  }
  constexpr void assign(size_type n, const T& u) { copy_assign(n, u); }
  constexpr void assign(initializer_list<T> const& il) {
    copy_assign(begin(il), end(il));
  }
  constexpr void assign(initializer_list<T>&& il) {
    move_assign(begin(il), end(il));
  }

  ///@}  // Construct/copy/move/destroy

  /// \name Iterators
  ///@{

  constexpr iterator begin() noexcept { return data(); }
  constexpr const_iterator begin() const noexcept { return data(); }
  constexpr iterator end() noexcept { return data() + size(); }
  constexpr const_iterator end() const noexcept { return data() + size(); }

  reverse_iterator rbegin() noexcept { return end() - 1; }
  const_reverse_iterator rbegin() const noexcept { return end() - 1; }
  reverse_iterator rend() noexcept { return data() - 1; }
  const_reverse_iterator rend() const noexcept { return data() - 1; }

  constexpr const_iterator cbegin() noexcept { return begin(); }
  constexpr const_iterator cbegin() const noexcept { return begin(); }
  constexpr const_iterator cend() noexcept { return end(); }
  constexpr const_iterator cend() const noexcept { return end(); }

///@}  // Iterators

/// \name size / capacity
///@{

#ifdef stack_vector_DOXYGEN_INVOKED
  /// Number of elements in the vector
  ///
  /// Complexity:
  /// - time: O(1)
  /// - space: O(1)
  ///
  /// Exception-safety:
  /// - never throws (noexcept(true))
  ///
  /// Constexpr:
  /// - if vector is constexpr
  ///
  /// Effect: none
  ///
  constexpr size_t size() const noexcept;
#endif  // stack_vector_DOXYGEN_INVOKED

  /// Number of elements that can be held in the vector storage
  ///
  /// Complexity:
  /// - time: O(1)
  /// - space: O(1)
  ///
  /// Exception-safety:
  /// - never throws (noexcept(true))
  ///
  /// Constexpr:
  /// - always
  ///
  /// Effect: none
  ///
  static constexpr size_type capacity() noexcept { return Capacity; }

  /// Maximum number of elements the container is able to hold due to system or
  /// library implementation limitations.
  ///
  /// Complexity:
  /// - time: O(1)
  /// - space: O(1)
  ///
  /// Exception-safety:
  /// - never throws (noexcept(true))
  ///
  /// Constexpr:
  /// - always
  ///
  /// Effect: none
  ///
  static constexpr size_type max_size() noexcept { return capacity(); }

#ifndef stack_vector_DOXYGEN_INVOKED
  // Explicitly deleted to improve error messages since the storage of the
  // vector cannot be resized
  void reserve(size_type n) = delete;
#endif  // stack_vector_DOXYGEN_INVOKED

  /// Resizes the container to contain \p sz elements. If elements need to be
  /// appended, these are copy-constructed from \p value.
  ///
  /// Complexity:
  /// - space: O(1)
  /// - time:
  ///   - if \p sz >= `size()`: exactly: (sz - `size()`)
  ///     copy-constructions of \p value
  ///   - if \p sz < `size()`: exactly (`size()` - sz) destructions
  ///     of values of type `T`.
  ///
  /// Exception-safety:
  /// - if an exception is thrown other than by the move constructor or the
  /// destructor of a non-CopyInsertable T there are no effects.
  /// - if sz > `capacity()` a `length_error` exception is thrown and there
  ///   are no effects.
  ///
  /// Constexpr:
  /// - if vector is constexpr, and:
  ///   - the copy-constructor of T is constexpr if (sz >= `size()`), or
  ///   - the destructor of T is constexpr if (sz < `size()`)
  ///
  /// Effect:
  /// - if sz == `size` no effects
  /// - if sz >= size, (sz - `size()`) copy-constructions of \p value and
  ///   `size()` will return \p sz on success.
  /// - if sz < size, (`size()` - sz) destructions of \p value and
  ///   `size()` will return \p sz on success.
  ///
  /// TODO: constrain: CopyInsertable
  constexpr void resize(size_type sz, T const& value) noexcept(
   is_nothrow_copy_constructible<T>{} and is_nothrow_destructible<T>{}) {
    if (sz == size()) { return; }
    if (sz > size()) {
      if (sz > capacity()) {
        throw length_error(
         "stack_vector cannot be resized to a size greater than capacity");
      }
      insert(end(), sz - size(), value);
    } else {
      erase(end() - (size() - sz), end());
    }
  }

  /// Resizes the container to contain \p sz elements. If elements need to be
  /// appended, these are move-constructed from `T{}` (or copy-constructed if
  /// `T` is not `MoveConstructible`).
  ///
  /// Complexity:
  /// - space: O(1)
  /// - time:
  ///   - if \p sz >= `size()`: exactly: (sz - `size()`)
  ///     move or copy-constructions of \p `T{}`
  ///   - if \p sz < `size()`: O(N), exactly (`size()` - sz) destructions
  ///     of values of type `T`.
  ///
  /// Exception-safety:
  /// - if an exception is thrown other than by the move constructor or the
  /// destructor of a non-CopyInsertable T there are no effects.
  /// - if sz > `capacity()` a `length_error` exception is thrown and there
  ///   are no effects.
  ///
  /// Constexpr:
  /// - if vector is constexpr, and:
  ///   - the copy-constructor of T is constexpr if (sz >= `size()`), or
  ///   - the destructor of T is constexpr if (sz < `size()`)
  ///
  /// Effect:
  /// - if sz == `size` no effects
  /// - if sz >= size, (sz - `size()`) copy-constructions of \p value and
  ///   `size()` will return \p sz on success.
  /// - if sz < size, (`size()` - sz) destructions of \p value and
  ///   `size()` will return \p sz on success.
  ///
  /// TODO: constrain: MoveInsertable and DefaultInsertable
  constexpr void resize(size_type sz) noexcept(
   is_nothrow_destructible<T>{}
   and ((is_move_constructible<T>{} and is_nothrow_move_constructible<T>{})
        or (is_copy_constructible<T>{}
            and is_nothrow_copy_constructible<T>{}))) {
    if (sz == size()) { return; }
    if (sz > size()) {
      if (sz > capacity()) {
        throw length_error(
         "stack_vector cannot be resized to a size greater than capacity");
      }
      insert(end(), sz - size(), T{});
    } else {
      erase(end() - (size() - sz), end());
    }
  }

  /// Checks whether the container is empty
  ///
  /// Complexity:
  /// - time: O(1)
  /// - space: O(1)
  ///
  /// Exception-safety:
  /// - never throws (noexcept(true))
  ///
  /// Constexpr:
  /// - if vector is constexpr
  ///
  /// Effects: none.
  constexpr bool empty() const noexcept { return size() == size_type(0); }

#ifndef stack_vector_DOXYGEN_INVOKED
  // Explicitly deleted to improve error messages since the storage of the
  // vector cannot be resized:
  void shrink_to_fit() = delete;
#endif  // stack_vector_DOXYGEN_INVOKED

  ///@}  // Size / capacity

  /// \name Element access
  ///@{

  constexpr reference operator[](size_type pos) noexcept {
    assert(pos < size());
    return *(begin() + pos);
  }

  constexpr const_reference operator[](size_type pos) const noexcept {
    assert(pos < size());
    return *(begin() + pos);
  }

  constexpr reference at(size_type pos) {
    if (pos >= size()) {
      throw out_of_range("cannot access stack_vector element at pos >= size");
    }
    return (*this)[pos];
  }

  constexpr const_reference at(size_type pos) const {
    if (pos >= size()) {
      throw out_of_range("cannot access stack_vector element at pos >= size");
    }
    return (*this)[pos];
  }

  constexpr reference front() noexcept {
    assert(size() > 0);
    return *begin();
  }
  constexpr const_reference front() const noexcept {
    assert(size() > 0);
    return *begin();
  }

  constexpr reference back() noexcept {
    assert(size() > 0);
    return *(end() - 1);
  }
  constexpr const_reference back() const noexcept {
    assert(size() > 0);
    return *(end() - 1);
  }

///@}  // Element access

#ifdef stack_vector_DOXYGEN_INVOKED
  /// \name Data access
  ///@{

  /// Direct access to the underlying storage
  ///
  /// Returns an unspecified value if the capacity of the vector is zero, but it
  /// is guaranteed that in that case data() == begin() == end().
  ///
  /// In this implementation the unspecified value is `nullptr`.
  ///
  /// Complexity:
  /// - time: O(1)
  /// - space: O(1)
  ///
  /// Exception-safety:
  /// - never throws (noexcept(true))
  ///
  /// Constexpr:
  /// - if vector is constexpr
  ///
  /// Effect: none
  ///
  constexpr const T* data() const noexcept;

  /// Direct access to the underlying storage
  ///
  /// Returns an unspecified value if the capacity of the vector is zero, but it
  /// is guaranteed that in that case data() == begin() == end().
  ///
  /// In this implementation the unspecified value is `nullptr`.
  ///
  /// Complexity:
  /// - time: O(1)
  /// - space: O(1)
  ///
  /// Constexpr:
  /// - if vector is constexpr
  ///
  /// Effect: none
  ///
  constexpr T* data() noexcept;

///@}  // Data access
#endif  // stack_vector_DOXYGEN_INVOKED

/// \name Modifiers
///@{

#ifdef stack_vector_DOXYGEN_INVOKED
  template <typename... Args> void emplace_back(Args&&... args);
#endif  // stack_vector_DOXYGEN_INVOKED

  /// Push back
  ///
  /// TODO: Cannot be constexpr because of emplace_back usage of placement
  /// TODO: constrain: , CONCEPT_REQUIRES_(Constructible<T, U>{})
  ///   /// TODO: make noexcept if same condition as emplace back
  template <typename U> void push_back(U&& value) {
    emplace_back(forward<U>(value));
  }

#ifdef stack_vector_DOXYGEN_INVOKED
  /// Pop back
  ///
  void pop_back() noexcept(is_nothrow_destructible<T>{});
#endif

  // template<class... Args>
  //   iterator emplace(const_iterator position, Args&&...args);
  // iterator insert(const_iterator position, const T& x);
  // iterator insert(const_iterator position, size_type n, const T& x);
  // template<class InputIterator>
  //   iterator insert(const_iterator position, InputIterator first,
  //   InputIterator last);

  // iterator insert(const_iterator position, initializer_list<T> il);
  // iterator erase(const_iterator position);
  // iterator erase(const_iterator first, const_iterator last);

  constexpr void clear() noexcept(is_nothrow_destructible<T>{}) {
    unsafe_destroy_all();
    unsafe_set_size(0);
  }

  // constexpr void swap(stack_vector<T, C>&)
  //   noexcept(noexcept(swap(declval<T&>(), declval<T&>()))));

  ///@}  // Modifiers
};

}  // namespace experimental
}  // namespace std

#endif  // STD_EXPERIMENTAL_STACK_VECTOR
