#ifndef STD_EXPERIMENTAL_STACK_VECTOR
#define STD_EXPERIMENTAL_STACK_VECTOR
/// \file
///
/// Dynamically-resizable vector with stack storage.
///
/// Copyright Gonzalo Brito Gadeschi 2015
///
/// This file is released under the Boost Software License:
//
// Boost Software License - Version 1.0 - August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//
//
// Some of the code has been adapted from libc++:
//
// and is annotated with "adapted from libc++" below, and is thus under the
// following license:
//
//===----------------------------------------------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
#include <cassert>
#include <cstddef>    // for size_t
#include <iterator>   // for reverse_iterator
#include <stdexcept>  // for length_error
#include <type_traits>

namespace std {
namespace experimental {

#ifndef stack_vector_DOXYGEN_INVOKED

namespace stack_vector_detail {

template <typename InputIt, typename OutputIt>
constexpr OutputIt move_backward(InputIt b, InputIt e, OutputIt to) {
  while (b != e) { *(--to) = move(*(--e)); }
  return to;
}

template <typename OutputIt, typename T>
constexpr OutputIt fill_n(OutputIt b, size_t n, const T& v) {
  for (; n > 0; ++b, --n) { *b = v; }
  return b;
}

template <typename T> constexpr void swap(T&& a, T&& b) {
  T&& tmp = std::move(a);
  a       = std::move(b);
  b       = std::move(tmp);
}

template <class ForwardIt>
constexpr void slow_rotate(ForwardIt first, ForwardIt n_first, ForwardIt last) {
  ForwardIt next = n_first;
  while (first != next) {
    swap(*(first++), *(next++));
    if (next == last) {
      next = n_first;
    } else if (first == n_first) {
      n_first = next;
    }
  }
}

/// Storage for a vector of non-trivial elements
template <typename T, size_t Capacity, bool IsTrivial /* = false */>
struct storage {
  static_assert(Capacity != size_t{0}, "");

 private:
  aligned_storage_t<sizeof(T), alignment_of<T>::value> data_[Capacity];
  size_t size_ = 0;

 public:
  /// Direct access to the underlying storage
  ///
  /// Time complexity: O(1)
  /// Space complexity: O(1)
  constexpr const T* data() const noexcept {
    return reinterpret_cast<T const*>(data_);
  }

  /// Direct access to the underlying storage
  ///
  /// Time complexity: O(1)
  /// Space complexity: O(1)
  constexpr T* data() noexcept { return reinterpret_cast<T*>(data_); }

  /// Number of elements in the vector
  ///
  /// Time complexity: O(1)
  /// Space complexity: O(1)
  constexpr size_t size() const noexcept { return size_; }

  /// TODO: constrain to Constructible<T, Args...>
  /// TODO: conditionally noexcept
  template <typename... Args>  //
  void emplace_back(Args&&... args) {
    assert(size() <= Capacity);
    new (data() + size()) T(forward<Args>(args)...);
    unsafe_set_size(size() + 1);
  }

  // calling pop back on an empty container is undefined
  // cannot be constexpr due to explicit destructor call
  void pop_back() noexcept(is_nothrow_destructible<T>{}) {
    assert(size() > 0);
    auto ptr = data() + size() - 1;
    ptr->~T();
    unsafe_set_size(size() - 1);
  }

 protected:
  /// Changes the container size (unsafe)
  constexpr void unsafe_set_size(size_t new_size) noexcept { size_ = new_size; }

  template <typename InputIt>
  constexpr void unsafe_destroy(InputIt first, InputIt last) noexcept {
    for (; first != last; ++first) { first->~T(); }
  }

  /// Destroys all elements of the vector without changing its size (unsafe)
  constexpr void unsafe_destroy_all() noexcept {
    unsafe_destroy(data(), data() + size());
  }

  /// Requires Copyable
  //
  // the only thing that can throw is the copy constructor, if it throws we
  // bail
  template <class InputIt>
  constexpr void copy_assign(InputIt first, InputIt last) {
    unsafe_destroy_all();
    unsafe_set_size(0);
    auto b = data();
    for (; first != last; ++first, ++b) {
      if (size() < Capacity) {
        new (b) T(*first);  // CopyConstructible
        ++size_;
      } else {
        unsafe_destroy_all();
        unsafe_set_size(0);
        throw length_error("");
      }
    }
  }

  /// Requires Movable (note: std::move_iterator is not constexpr)
  template <class InputIt>
  constexpr void move_assign(InputIt first, InputIt last) {
    unsafe_destroy_all();
    unsafe_set_size(0);
    auto b = data();
    for (; first != last; ++first, ++b) {
      if (size() < Capacity) {
        new (b) T(std::move(*first));  // MoveConstructible
        ++size_;
      } else {
        unsafe_destroy_all();
        unsafe_set_size(0);
        throw length_error("");
      }
    }
  }

  constexpr void copy_assign(size_t n, T const& u) {
    unsafe_destroy_all();
    unsafe_set_size(0);
    auto b = data();
    for (; n != 0; --n, ++b) {
      if (size() < Capacity) {
        new (b) T(u);  // CopyConstructible
        ++size_;
      } else {
        unsafe_destroy_all();
        unsafe_set_size(0);
        throw length_error("");
      }
    }
  }

 public:
  constexpr storage()               = default;
  constexpr storage(storage const&) = default;
  constexpr storage& operator=(storage const&) = default;
  constexpr storage(storage&&)                 = default;
  constexpr storage& operator=(storage&&) = default;
  ~storage() { unsafe_destroy_all(); }
};

/// Storage for a vector of trivial elements
template <typename T, size_t Capacity>  //
struct storage<T, Capacity, true> {
  static_assert(Capacity != size_t{0}, "");

 private:
  T data_[Capacity]{};
  size_t size_ = 0;

 public:
  /// Direct access to the underlying storage
  ///
  /// Time complexity: O(1)
  /// Space complexity: O(1)
  constexpr const T* data() const noexcept { return data_; }

  /// Direct access to the underlying storage
  ///
  /// Time complexity: O(1)
  /// Space complexity: O(1)
  constexpr T* data() noexcept { return data_; }

  /// Number of elements in the vector
  ///
  /// Time complexity: O(1)
  /// Space complexity: O(1)
  constexpr size_t size() const noexcept { return size_; }

  /// TODO: constrain to Constructible<T, Args...> and (MoveAssignable<T> or
  /// CopyAssignable<T>)
  /// TODO: conditionally noexcept
  template <typename... Args>  //
  constexpr void emplace_back(Args&&... args) {
    assert(size() <= Capacity);
    data_[size()] = T(forward<Args>(args)...);
    unsafe_set_size(size() + 1);
  }

  // calling pop back on an empty container is undefined
  constexpr void pop_back() noexcept {
    assert(size() > 0);
    unsafe_set_size(size() - 1);
  }

 protected:
  /// Changes the container size (unsafe)
  constexpr void unsafe_set_size(size_t new_size) noexcept { size_ = new_size; }

  template <typename InputIt>
  constexpr void unsafe_destroy(InputIt, InputIt) noexcept {}

  /// Destroys all elements of the vector without changing its size (unsafe)
  static constexpr void unsafe_destroy_all() noexcept {}

  template <class InputIt> void copy_assign(InputIt first, InputIt last) {
    size_t new_size = 0;
    auto b          = data();
    for (; first != last; ++first, ++b) {
      if (new_size < Capacity) {
        *b = *first;
        ++b;
        ++new_size;
      } else {
        throw length_error("");
      }
    }
    unsafe_set_size(new_size);
  }

  template <class InputIt> void move_assign(InputIt first, InputIt last) {
    size_t new_size = 0;
    auto b          = data();
    for (; first != last; ++first, ++b) {
      if (new_size < Capacity) {
        *b = std::move(*first);
        ++b;
        ++new_size;
      } else {
        throw length_error("");
      }
    }
    unsafe_set_size(new_size);
  }

  void copy_assign(size_t n, const T& u) {
    if (n > Capacity) { throw length_error(""); }
    for (size_t i = 0; i != n; ++i) { data_[i] = u; }
    unsafe_set_size(n);
  }

 public:
  constexpr storage()               = default;
  constexpr storage(storage const&) = default;
  template <typename Value, typename... Values,
            typename = enable_if_t<!is_same<decay_t<Value>, storage>{}>>
  constexpr storage(Value&& v, Values&&... vs)
   : data_{std::forward<Value>(v), std::forward<Values>(vs)...} {
    static_assert(sizeof...(Values) + 1 <= Capacity, "");
    unsafe_set_size(sizeof...(Values) + 1);
  }
  constexpr storage& operator=(storage const&) = default;
  constexpr storage(storage&&)                 = default;
  constexpr storage& operator=(storage&&) = default;
  // constexpr ~storage()                    = default;
};

template <typename T> struct empty_storage {
  /// Direct access to the underlying storage
  ///
  /// Time complexity: O(1)
  /// Space complexity: O(1)
  constexpr const T* data() const noexcept { return nullptr; }

  /// Direct access to the underlying storage
  ///
  /// Time complexity: O(1)
  /// Space complexity: O(1)
  constexpr T* data() noexcept { return nullptr; }

  /// Number of elements in the vector
  ///
  /// Time complexity: O(1)
  /// Space complexity: O(1)
  static constexpr size_t size() noexcept { return 0; }

  /// Changes the container size (unsafe)
  static constexpr void unsafe_set_size(size_t new_size) noexcept {
    assert(new_size == size_t{0}
           && "trying to set the size of a zero-capacity vector to value != 0");
  }

  /// For trivially destructible types there is nothing to do
  static constexpr void unsafe_destroy_all() noexcept {}

  template <typename... Args>  //
  static constexpr void emplace_back(Args&&...) {
    assert(false);
  }

  static constexpr void pop_back() noexcept { assert(false); }

  template <class InputIt> void copy_assign(InputIt first, InputIt last) {
    assert(first == last);
  }

  template <class InputIt> void move_assign(InputIt first, InputIt last) {
    assert(first == last);
  }

  void copy_assign(size_t n, const T&) { assert(n == size_t(0)); }
};

template <typename T>  //
struct storage<T, 0, true> : empty_storage<T> {};

template <typename T>  //
struct storage<T, 0, false> : empty_storage<T> {};

}  // namespace stack_vector_detail

#endif  // stack_vector_DOXYGEN_INVOKED

/// Dynamically-resizable vector with stack storage
template <typename T, size_t Capacity>  //
struct stack_vector
 : private stack_vector_detail::storage<T, Capacity, is_trivial<T>{}> {
 private:
  using self   = stack_vector<T, Capacity>;
  using base_t = stack_vector_detail::storage<T, Capacity, is_trivial<T>{}>;

 public:
  using base_t::data;
  using base_t::size;
  using base_t::emplace_back;
  using base_t::pop_back;

 private:
  using base_t::unsafe_set_size;
  using base_t::unsafe_destroy_all;
  using base_t::copy_assign;
  using base_t::move_assign;

  static_assert(is_nothrow_destructible<T>{},
                "stack::vector requires T to be nothrow destructible");

 public:
  using value_type             = T;
  using reference              = value_type&;
  using const_reference        = value_type const&;
  using iterator               = T*;
  using const_iterator         = T const*;
  using size_type              = size_t;
  using difference_type        = ptrdiff_t;
  using pointer                = T*;
  using const_pointer          = T const*;
  using reverse_iterator       = typename std::reverse_iterator<iterator>;
  using const_reverse_iterator = typename std::reverse_iterator<const_iterator>;

  /// \name Construct/copy/move/destroy
  ///@{

  constexpr stack_vector() noexcept : base_t() {}

  /// Can always throw if n > capacity
  constexpr explicit stack_vector(size_type n) { copy_assign(n, T()); };

  /// can always throw if n > Capacity
  constexpr stack_vector(size_type n, const T& value) { copy_assign(n, value); }

  /// TODO: assert distance for RandomAccessIterator (QoI)
  /// can always throw if distance(first, last) > capacity
  template <class InputIt> constexpr stack_vector(InputIt first, InputIt last) {
    copy_assign(std::move(first), std::move(last));
  }

  /// can always throw if other.size() > capacity() which can only happen if M
  /// >
  /// Capacity
  template <std::size_t M, enable_if_t<(Capacity != M)>>
  constexpr stack_vector(stack_vector<T, M> const& other) noexcept(
   M <= Capacity and is_nothrow_copy_constructible<T>{}
   and is_nothrow_copy_assignable<T>{}) {
    copy_assign(begin(other), end(other));
  }

  /// can always throw if other.size() > capacity() which can only happen if M
  /// >
  /// Capacity
  template <std::size_t M, enable_if_t<(Capacity != M)>>
  constexpr stack_vector(stack_vector<T, M>&& other) noexcept(
   M <= Capacity and is_nothrow_move_constructible<T>{}
   and is_nothrow_move_assignable<T>{}) {
    move_assign(begin(other), end(other));
  }

  /// same capacity so can only throw if copy constructor or copy assignment
  /// can
  /// throw
  constexpr stack_vector(stack_vector const& other) noexcept(
   is_nothrow_copy_assignable<T>{} and is_nothrow_copy_constructible<T>{}) {
    copy_assign(begin(other), end(other));
  }

  /// same capacity so can only throw if move constructor or move assignment
  /// can
  /// throw
  constexpr stack_vector(stack_vector&& other) noexcept(
   is_nothrow_move_assignable<T>{} and is_nothrow_move_constructible<T>{}) {
    move_assign(begin(other), end(other));
  }
  // can always throw if il.size() > capacity()
  template <typename Value, typename... Values>
  constexpr stack_vector(Value&& v, Values&&... vs)
   : base_t(std::forward<Value>(v), std::forward<Values>(vs)...) {}

  // using base_t::~base_t;  // inheriting the destructor allows this type to
  // be
  //                         // trivially destructible

  /// same capacity so can only thow if copy constructor or copy assignment
  /// throws
  ///
  /// cannot provide strong exception guarantee
  constexpr stack_vector& operator=(stack_vector const& other) noexcept(
   is_nothrow_copy_constructible<T>{} and is_nothrow_copy_assignable<T>{}) {
    copy_assign(begin(other), end(other));
  }
  /// same capacity so can only thow if copy constructor or copy assignment
  /// throws
  ///
  /// cannot provide strong exception guarantee
  constexpr stack_vector& operator=(stack_vector&& other) noexcept(
   is_nothrow_move_assignable<T>{} and is_nothrow_move_constructible<T>{}) {
    move_assign(begin(other), end(other));
  }

  /// TODO: conditionally noexcept
  template <std::size_t M, enable_if_t<(Capacity != M)>>
  constexpr stack_vector& operator=(stack_vector<T, M> const& other) noexcept(
   is_nothrow_copy_constructible<T>{} and is_nothrow_copy_assignable<T>{}) {
    copy_assign(begin(other), end(other));
  }
  /// TODO: conditionally noexcept
  template <std::size_t M, enable_if_t<(Capacity != M)>>
  constexpr stack_vector& operator=(stack_vector<T, M>&& other) noexcept(
   is_nothrow_move_assignable<T>{} and is_nothrow_move_constructible<T>{}) {
    move_assign(begin(other), end(other));
  }

  template <class InputIt> constexpr void assign(InputIt first, InputIt last) {
    copy_assign(first, last);
  }
  constexpr void assign(size_type n, const T& u) { copy_assign(n, u); }
  constexpr void assign(initializer_list<T> const& il) {
    copy_assign(begin(il), end(il));
  }
  constexpr void assign(initializer_list<T>&& il) {
    move_assign(begin(il), end(il));
  }

  ///@}  // Construct/copy/move/destroy

  /// \name Iterators
  ///@{

  constexpr iterator begin() noexcept { return data(); }
  constexpr const_iterator begin() const noexcept { return data(); }
  constexpr iterator end() noexcept { return data() + size(); }
  constexpr const_iterator end() const noexcept { return data() + size(); }

  reverse_iterator rbegin() noexcept { return end() - 1; }
  const_reverse_iterator rbegin() const noexcept { return end() - 1; }
  reverse_iterator rend() noexcept { return data() - 1; }
  const_reverse_iterator rend() const noexcept { return data() - 1; }

  constexpr const_iterator cbegin() noexcept { return begin(); }
  constexpr const_iterator cbegin() const noexcept { return begin(); }
  constexpr const_iterator cend() noexcept { return end(); }
  constexpr const_iterator cend() const noexcept { return end(); }

///@}  // Iterators

/// \name size / capacity
///@{

#ifdef stack_vector_DOXYGEN_INVOKED
  /// Number of elements in the vector
  ///
  /// Complexity:
  /// - time: O(1)
  /// - space: O(1)
  ///
  /// Exception-safety:
  /// - never throws (noexcept(true))
  ///
  /// Constexpr:
  /// - if vector is constexpr
  ///
  /// Effect: none
  ///
  constexpr size_t size() const noexcept;
#endif  // stack_vector_DOXYGEN_INVOKED

  /// Number of elements that can be held in the vector storage
  ///
  /// Complexity:
  /// - time: O(1)
  /// - space: O(1)
  ///
  /// Exception-safety:
  /// - never throws (noexcept(true))
  ///
  /// Constexpr:
  /// - always
  ///
  /// Effect: none
  ///
  static constexpr size_type capacity() noexcept { return Capacity; }

  /// Maximum number of elements the container is able to hold due to system or
  /// library implementation limitations.
  ///
  /// Complexity:
  /// - time: O(1)
  /// - space: O(1)
  ///
  /// Exception-safety:
  /// - never throws (noexcept(true))
  ///
  /// Constexpr:
  /// - always
  ///
  /// Effect: none
  ///
  static constexpr size_type max_size() noexcept { return capacity(); }

#ifndef stack_vector_DOXYGEN_INVOKED
  // Explicitly deleted to improve error messages since the storage of the
  // vector cannot be resized
  void reserve(size_type n) = delete;
#endif  // stack_vector_DOXYGEN_INVOKED

  /// Resizes the container to contain \p sz elements. If elements need to be
  /// appended, these are copy-constructed from \p value.
  ///
  /// Complexity:
  /// - space: O(1)
  /// - time:
  ///   - if \p sz >= `size()`: exactly: (sz - `size()`)
  ///     copy-constructions of \p value
  ///   - if \p sz < `size()`: exactly (`size()` - sz) destructions
  ///     of values of type `T`.
  ///
  /// Exception-safety:
  /// - if an exception is thrown other than by the move constructor or the
  /// destructor of a non-CopyInsertable T there are no effects.
  /// - if sz > `capacity()` a `length_error` exception is thrown and there
  ///   are no effects.
  ///
  /// Constexpr:
  /// - if vector is constexpr, and:
  ///   - the copy-constructor of T is constexpr if (sz >= `size()`), or
  ///   - the destructor of T is constexpr if (sz < `size()`)
  ///
  /// Effect:
  /// - if sz == `size` no effects
  /// - if sz >= size, (sz - `size()`) copy-constructions of \p value and
  ///   `size()` will return \p sz on success.
  /// - if sz < size, (`size()` - sz) destructions of \p value and
  ///   `size()` will return \p sz on success.
  ///
  /// TODO: constrain: CopyInsertable
  constexpr void resize(size_type sz, T const& value) noexcept(
   is_nothrow_copy_constructible<T>{} and is_nothrow_destructible<T>{}) {
    if (sz == size()) { return; }
    if (sz > size()) {
      if (sz > capacity()) {
        throw length_error(
         "stack_vector cannot be resized to a size greater than capacity");
      }
      insert(end(), sz - size(), value);
    } else {
      erase(end() - (size() - sz), end());
    }
  }

  /// Resizes the container to contain \p sz elements. If elements need to be
  /// appended, these are move-constructed from `T{}` (or copy-constructed if
  /// `T` is not `MoveConstructible`).
  ///
  /// Complexity:
  /// - space: O(1)
  /// - time:
  ///   - if \p sz >= `size()`: exactly: (sz - `size()`)
  ///     move or copy-constructions of \p `T{}`
  ///   - if \p sz < `size()`: O(N), exactly (`size()` - sz) destructions
  ///     of values of type `T`.
  ///
  /// Exception-safety:
  /// - if an exception is thrown other than by the move constructor or the
  /// destructor of a non-CopyInsertable T there are no effects.
  /// - if sz > `capacity()` a `length_error` exception is thrown and there
  ///   are no effects.
  ///
  /// Constexpr:
  /// - if vector is constexpr, and:
  ///   - the copy-constructor of T is constexpr if (sz >= `size()`), or
  ///   - the destructor of T is constexpr if (sz < `size()`)
  ///
  /// Effect:
  /// - if sz == `size` no effects
  /// - if sz >= size, (sz - `size()`) copy-constructions of \p value and
  ///   `size()` will return \p sz on success.
  /// - if sz < size, (`size()` - sz) destructions of \p value and
  ///   `size()` will return \p sz on success.
  ///
  /// TODO: constrain: MoveInsertable and DefaultInsertable
  constexpr void resize(size_type sz) noexcept(
   is_nothrow_destructible<T>{}
   and ((is_move_constructible<T>{} and is_nothrow_move_constructible<T>{})
        or (is_copy_constructible<T>{}
            and is_nothrow_copy_constructible<T>{}))) {
    if (sz == size()) { return; }
    if (sz > size()) {
      if (sz > capacity()) {
        throw length_error(
         "stack_vector cannot be resized to a size greater than capacity");
      }
      insert(end(), sz - size(), T{});
    } else {
      erase(end() - (size() - sz), end());
    }
  }

  /// Checks whether the container is empty
  ///
  /// Complexity:
  /// - time: O(1)
  /// - space: O(1)
  ///
  /// Exception-safety:
  /// - never throws (noexcept(true))
  ///
  /// Constexpr:
  /// - if vector is constexpr
  ///
  /// Effects: none.
  constexpr bool empty() const noexcept { return size() == size_type(0); }

#ifndef stack_vector_DOXYGEN_INVOKED
  // Explicitly deleted to improve error messages since the storage of the
  // vector cannot be resized:
  void shrink_to_fit() = delete;
#endif  // stack_vector_DOXYGEN_INVOKED

  ///@}  // Size / capacity

  /// \name Element access
  ///@{

  constexpr reference operator[](size_type pos) noexcept {
    assert(pos < size());
    return *(begin() + pos);
  }

  constexpr const_reference operator[](size_type pos) const noexcept {
    assert(pos < size());
    return *(begin() + pos);
  }

  constexpr reference at(size_type pos) {
    if (pos >= size()) {
      throw out_of_range("cannot access stack_vector element at pos >= size");
    }
    return (*this)[pos];
  }

  constexpr const_reference at(size_type pos) const {
    if (pos >= size()) {
      throw out_of_range("cannot access stack_vector element at pos >= size");
    }
    return (*this)[pos];
  }

  constexpr reference front() noexcept {
    assert(size() > 0);
    return *begin();
  }
  constexpr const_reference front() const noexcept {
    assert(size() > 0);
    return *begin();
  }

  constexpr reference back() noexcept {
    assert(size() > 0);
    return *(end() - 1);
  }
  constexpr const_reference back() const noexcept {
    assert(size() > 0);
    return *(end() - 1);
  }

///@}  // Element access

#ifdef stack_vector_DOXYGEN_INVOKED
  /// \name Data access
  ///@{

  /// Direct access to the underlying storage
  ///
  /// Returns an unspecified value if the capacity of the vector is zero, but
  /// it
  /// is guaranteed that in that case data() == begin() == end().
  ///
  /// In this implementation the unspecified value is `nullptr`.
  ///
  /// Complexity:
  /// - time: O(1)
  /// - space: O(1)
  ///
  /// Exception-safety:
  /// - never throws (noexcept(true))
  ///
  /// Constexpr:
  /// - if vector is constexpr
  ///
  /// Effect: none
  ///
  constexpr const T* data() const noexcept;

  /// Direct access to the underlying storage
  ///
  /// Returns an unspecified value if the capacity of the vector is zero, but
  /// it
  /// is guaranteed that in that case data() == begin() == end().
  ///
  /// In this implementation the unspecified value is `nullptr`.
  ///
  /// Complexity:
  /// - time: O(1)
  /// - space: O(1)
  ///
  /// Constexpr:
  /// - if vector is constexpr
  ///
  /// Effect: none
  ///
  constexpr T* data() noexcept;

///@}  // Data access
#endif  // stack_vector_DOXYGEN_INVOKED

/// \name Modifiers
///@{

#ifdef stack_vector_DOXYGEN_INVOKED
  template <typename... Args> void emplace_back(Args&&... args);
#endif  // stack_vector_DOXYGEN_INVOKED

  /// Push back
  ///
  /// TODO: Cannot be constexpr because of emplace_back usage of placement
  /// TODO: constrain: , CONCEPT_REQUIRES_(Constructible<T, U>{})
  ///   /// TODO: make noexcept if same condition as emplace back
  template <typename U> void push_back(U&& value) {
    emplace_back(forward<U>(value));
  }

#ifdef stack_vector_DOXYGEN_INVOKED
  /// Pop back
  ///
  void pop_back() noexcept(is_nothrow_destructible<T>{});
#endif

  template <class... Args>
  constexpr iterator emplace(const_iterator position, Args&&... args) {
    insert(position, value_type(forward<Args>(args)...));
  }
  constexpr iterator insert(const_iterator position, const_reference x) {
    insert(position, size_type(1), x);
  }
  constexpr iterator insert(const_iterator position, size_type n, const T& x) {
    const auto new_size = size() + n;
    if (new_size > capacity()) throw length_error("");
    stack_vector_detail::move_backward(position, end(), position + n);
    stack_vector_detail::fill_n(position, n, x);
    unsafe_set_size(new_size);
    return position;
  }

  template <class InputIt>
  constexpr iterator insert(const_iterator position, InputIt first,
                            InputIt last) {
    // Decided against optimization for ForwardIterator: we could compute the
    // distance and throw early if it exceeds the capacity, but that makes
    // things faster in the exceptional path, and the extra distance computation
    // makes things slower in the non-exceptional path.
    //
    // TODO: apply this optimization for RandomAccessIterator since then it has
    // ~zero-cost.
    auto b = end();
    //    try {  // if copy_constructor throws you get basic-guarantee?
    for (; first != last; ++first) { push_back(*first); }
    // } catch (...) {
    //   erase(b, end());
    //   throw;
    // }
    // we insert at the end and then just rotate:
    stack_vector_detail::slow_rotate(position, b, end());
  }

  constexpr iterator insert(const_iterator position, initializer_list<T> il) {
    insert(position, begin(il), end(il));
  }
  constexpr iterator erase(const_iterator position) {
    erase(position, position + 1);
  }
  constexpr iterator erase(const_iterator first, const_iterator last) {
    iterator f = begin() + (first - begin());
    iterator l = begin() + (last - begin());
    if (last != end()) {
      for (iterator i = l + 1, e = end(); i != e; ++i) {
        using stack_vector_detail::swap;
        swap(*i, *(f++));
      }
    }
    unsafe_set_size(size() - (end() - f));
    unsafe_destroy(f, l);
    return end();
  }

  constexpr void clear() noexcept(is_nothrow_destructible<T>{}) {
    unsafe_destroy_all();
    unsafe_set_size(0);
  }

  // TODO: this is rough
  constexpr void swap(stack_vector& other) noexcept(
   noexcept(swap(declval<T&>(), declval<T&>()))) {
    stack_vector tmp = other;
    other            = (*this);
    (*this)          = tmp;
  }

  ///@}  // Modifiers
};

}  // namespace experimental
}  // namespace std

#endif  // STD_EXPERIMENTAL_STACK_VECTOR
